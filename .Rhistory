stop("Data must be a matrix containing only 1s and 0s")
}
N <- ncol(data)
G <- nrow(data)
if(is.null(group_constraint)) group_constraint <- rep(1,G)
if(is.null(ind_constraint)) ind_constraint <- rep(1,N)
if(!is.vector(group_constraint) | length(group_constraint) != G | any(is.na(group_constraint))) stop("group_constraint must be a vector with length equal to the number of groups")
if(!is.vector(ind_constraint) | length(ind_constraint) != N | any(is.na(ind_constraint))) stop("ind_constraint must be a vector with length equal to the number of individuals")
if(is.null(FUN)){
FUN <- function(gbi){
x <- get_numerator(gbi,data_format="GBI",return="vector")
d <- get_denominator(gbi,data_format="GBI",return="vector")
sri <- x/d
res <- c(mean(sri,na.rm=T),sd(sri,na.rm=T),sd(sri,na.rm=T)/mean(sri,na.rm=T),mean(sri > 0, na.rm=T))
names(res) <- c("Mean","SD","CV","Non-zero")
return(res)
}
}
if(!is.function(FUN)) stop("FUN must be a function")
observed <- FUN(data,...)
chain_res <- list()
final_gbis <- list()
for(k in 1:chains){
gbi.p <- data
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
for(i in 1:(burnin*thin)){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,...)
}
final_gbis[[k]] <- gbi.p
chain_res[[k]] <- coda::mcmc(res_matrix, thin = thin, start = thin, end = thin*samples)
}
chain_res <- coda::mcmc.list(chain_res)
results <- list(
FUN = FUN,
ind_constraint = ind_constraint,
group_constraint = group_constraint,
control = list(thin = thin, samples = samples, burnin =burnin),
permuted_data = final_gbis,
observed = observed,
mcmc = chain_res
)
class(results) <- "gbi_null"
return(results)
}
x <- gbi_MCMC(data, FUN = f, s = 1:10)
f
f(gbi,1:10)
x
g
gbi
x
data
f(data,1:10)
f(data,1:10)
thin*samples
thin = 10
samples = 1000
thin*samples
thin
res_matrix
x <- res_matrix(nrow = 100, ncol =1)
x
x <- matrix(nrow = 100, ncol =1)
x
x[1,] <- 2
x
gbi_MCMC <- function(data,
ind_constraint = NULL,
group_constraint = NULL,
samples = 1000,
thin = 100,
burnin = 1000,
chains = 2,
FUN = NULL,
...){
if(!is.matrix(data) | any(!c(data) %in% c(0,1)) | any(is.na(data))){
stop("Data must be a matrix containing only 1s and 0s")
}
N <- ncol(data)
G <- nrow(data)
if(is.null(group_constraint)) group_constraint <- rep(1,G)
if(is.null(ind_constraint)) ind_constraint <- rep(1,N)
if(!is.vector(group_constraint) | length(group_constraint) != G | any(is.na(group_constraint))) stop("group_constraint must be a vector with length equal to the number of groups")
if(!is.vector(ind_constraint) | length(ind_constraint) != N | any(is.na(ind_constraint))) stop("ind_constraint must be a vector with length equal to the number of individuals")
if(is.null(FUN)){
FUN <- function(gbi){
x <- get_numerator(gbi,data_format="GBI",return="vector")
d <- get_denominator(gbi,data_format="GBI",return="vector")
sri <- x/d
res <- c(mean(sri,na.rm=T),sd(sri,na.rm=T),sd(sri,na.rm=T)/mean(sri,na.rm=T),mean(sri > 0, na.rm=T))
names(res) <- c("Mean","SD","CV","Non-zero")
return(res)
}
}
if(!is.function(FUN)) stop("FUN must be a function")
observed <- FUN(data,...)
chain_res <- list()
final_gbis <- list()
for(k in 1:chains){
gbi.p <- data
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
for(i in 1:(burnin*thin)){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,...)
}
final_gbis[[k]] <- gbi.p
chain_res[[k]] <- coda::mcmc(res_matrix)
}
chain_res <- coda::mcmc.list(chain_res)
results <- list(
FUN = FUN,
ind_constraint = ind_constraint,
group_constraint = group_constraint,
control = list(thin = thin, samples = samples, burnin =burnin),
permuted_data = final_gbis,
observed = observed,
mcmc = chain_res
)
class(results) <- "gbi_null"
return(results)
}
x <- gbi_MCMC(data, FUN = f, s = 1:10)
samples
x <- gbi_MCMC(data, FUN = f, samples = 100, s = 1:10)
gbi_MCMC <- function(data,
ind_constraint = NULL,
group_constraint = NULL,
samples = 1000,
thin = 100,
burnin = 1000,
chains = 2,
FUN = NULL,
...){
if(!is.matrix(data) | any(!c(data) %in% c(0,1)) | any(is.na(data))){
stop("Data must be a matrix containing only 1s and 0s")
}
N <- ncol(data)
G <- nrow(data)
if(is.null(group_constraint)) group_constraint <- rep(1,G)
if(is.null(ind_constraint)) ind_constraint <- rep(1,N)
if(!is.vector(group_constraint) | length(group_constraint) != G | any(is.na(group_constraint))) stop("group_constraint must be a vector with length equal to the number of groups")
if(!is.vector(ind_constraint) | length(ind_constraint) != N | any(is.na(ind_constraint))) stop("ind_constraint must be a vector with length equal to the number of individuals")
if(is.null(FUN)){
FUN <- function(gbi){
x <- get_numerator(gbi,data_format="GBI",return="vector")
d <- get_denominator(gbi,data_format="GBI",return="vector")
sri <- x/d
res <- c(mean(sri,na.rm=T),sd(sri,na.rm=T),sd(sri,na.rm=T)/mean(sri,na.rm=T),mean(sri > 0, na.rm=T))
names(res) <- c("Mean","SD","CV","Non-zero")
return(res)
}
}
if(!is.function(FUN)) stop("FUN must be a function")
observed <- FUN(data,...)
chain_res <- list()
final_gbis <- list()
for(k in 1:chains){
gbi.p <- data
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
for(i in 1:(burnin*thin)){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,...)
}
final_gbis[[k]] <- gbi.p
chain_res[[k]] <- coda::mcmc(res_matrix, thin = (burnin+1)*thin, start = thin, end = thin*(samples+burnin))
}
chain_res <- coda::mcmc.list(chain_res)
results <- list(
FUN = FUN,
ind_constraint = ind_constraint,
group_constraint = group_constraint,
control = list(thin = thin, samples = samples, burnin =burnin),
permuted_data = final_gbis,
observed = observed,
mcmc = chain_res
)
class(results) <- "gbi_null"
return(results)
}
x <- gbi_MCMC(data, FUN = f, samples = 100, s = 1:10)
x
x <- gbi_MCMC(data, FUN = f, samples = 100, thin = 10, s = 1:10)
x
plot(x)
x$mcmc
x$mcmc[[``]]
x$mcmc[[1]]
gbi_MCMC <- function(data,
ind_constraint = NULL,
group_constraint = NULL,
samples = 1000,
thin = 100,
burnin = 1000,
chains = 2,
FUN = NULL,
...){
if(!is.matrix(data) | any(!c(data) %in% c(0,1)) | any(is.na(data))){
stop("Data must be a matrix containing only 1s and 0s")
}
N <- ncol(data)
G <- nrow(data)
if(is.null(group_constraint)) group_constraint <- rep(1,G)
if(is.null(ind_constraint)) ind_constraint <- rep(1,N)
if(!is.vector(group_constraint) | length(group_constraint) != G | any(is.na(group_constraint))) stop("group_constraint must be a vector with length equal to the number of groups")
if(!is.vector(ind_constraint) | length(ind_constraint) != N | any(is.na(ind_constraint))) stop("ind_constraint must be a vector with length equal to the number of individuals")
if(is.null(FUN)){
FUN <- function(gbi){
x <- get_numerator(gbi,data_format="GBI",return="vector")
d <- get_denominator(gbi,data_format="GBI",return="vector")
sri <- x/d
res <- c(mean(sri,na.rm=T),sd(sri,na.rm=T),sd(sri,na.rm=T)/mean(sri,na.rm=T),mean(sri > 0, na.rm=T))
names(res) <- c("Mean","SD","CV","Non-zero")
return(res)
}
}
if(!is.function(FUN)) stop("FUN must be a function")
observed <- FUN(data,...)
chain_res <- list()
final_gbis <- list()
for(k in 1:chains){
gbi.p <- data
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
for(i in 1:(burnin*thin)){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,...)
}
final_gbis[[k]] <- gbi.p
chain_res[[k]] <- coda::mcmc(res_matrix, thin = thin, start =(burnin+1)*thin, end = thin*(samples+burnin))
}
chain_res <- coda::mcmc.list(chain_res)
results <- list(
FUN = FUN,
ind_constraint = ind_constraint,
group_constraint = group_constraint,
control = list(thin = thin, samples = samples, burnin =burnin),
permuted_data = final_gbis,
observed = observed,
mcmc = chain_res
)
class(results) <- "gbi_null"
return(results)
}
x <- gbi_MCMC(data, FUN = f, samples = 100, thin = 10, s = 1:10)
nrow(x$mcmc[[1]])
plot(x$mcmc[[1]])
plot(x$mcmc[[1]])
plot(x$mcmc[[2]])
x <- gbi_MCMC(data, FUN = f, samples = 100, thin = 100, s = 1:10)
x$control
chains <- length(x$mcmc)
chains
plot(x$mcmc)
observed <- x$observed
observed
initial_samples <- x$control$samples
initial_samples
observed <- x$observed
initial_samples <- x$control$samples
chains <- length(x$mcmc)
burnin <- x$control$burnin
thin <- x$control$thin
N <- ncol(x$permuted_data[[1]])
G <- nrow(x$permuted_data[[1]])
group_constraint <- x$group_constraint
ind_constraint <- x$ind_constraint
chain_res <- list()
final_gbis <- list()
k = 1
gbi.p <- data
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
FUN <- x$FUN
FUN
samples
samples <- 10
gbi.p <- data
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
thin
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,...)
}
FUN <- x$FUN
for(k in 1:chains){
gbi.p <- data
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,s = s)
}
gbi.p <- data
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,s=s)
}
s
gbi.p <- x$permuted_data[[k]]
gbi.p <- x$permuted_data[[k]]
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,s = 1:10)
}
res_matrix
rbind(as.matrix(x$mcmc[[k]]),res_matrix)
res_matrix <- rbind(as.matrix(x$mcmc[[k]]),res_matrix)
x$group_constraint
x$ind_constraint
x
extend.gbi_MCMC <- function(x,samples,...){
if(samples %% 1 != 0) stop("Argument samples must be an integer")
if(class(x) != "gbi_null") stop("Can only extend gbi_null objects")
observed <- x$observed
initial_samples <- x$control$samples
chains <- length(x$mcmc)
burnin <- x$control$burnin
thin <- x$control$thin
N <- ncol(x$permuted_data[[1]])
G <- nrow(x$permuted_data[[1]])
group_constraint <- x$group_constraint
ind_constraint <- x$ind_constraint
chain_res <- list()
final_gbis <- list()
FUN <- x$FUN
for(k in 1:chains){
gbi.p <- x$permuted_data[[k]]
res_matrix <- matrix(nrow = samples, ncol = length(observed))
colnames(res_matrix) <- names(observed)
for(i in 1:samples){
for(j in 1:thin){
cols <- sample(N,2)
rows <- sample(G,2)
trial_matrix <- gbi.p[rows,cols]
if( all(rowSums(trial_matrix) == 1) &
all(colSums(trial_matrix) == 1) &
group_constraint[rows[1]] == group_constraint[rows[2]] &
ind_constraint[cols[1]] == ind_constraint[cols[2]]){
trial_matrix <- ifelse(trial_matrix == 1, 0, 1)
gbi.p[rows,cols] <- trial_matrix
}
}
res_matrix[i,] <- FUN(gbi.p,...)
}
res_matrix <- rbind(as.matrix(x$mcmc[[k]]),res_matrix)
final_gbis[[k]] <- gbi.p
chain_res[[k]] <- coda::mcmc(res_matrix, thin = thin, start =(burnin+1)*thin, end = thin*(initial_samples+samples+burnin))
}
x$mcmc <- coda::mcmc.list(chain_res)
x$permuted_data <- final_gbis
x$control$samples <- x$control$samples + samples
return(x)
}
extend.gbi_MCMC(x,samples = 10, s = 1:10)
extend.gbi_MCMC(x,samples = 1000, s = 1:10)
extend.gbi_MCMC(x,samples = 10, s = 1:10)
extend.gbi_MCMC(x,samples = 10, s = 1:10)
extend.gbi_MCMC(x,samples = 10, s = 1:10)
extend.gbi_MCMC(x,samples = 10, s = 1:10)
extend.gbi_MCMC(x,samples = 10, s = 1:10)
extend.gbi_MCMC(x,samples = 10, s = 1:10)
extend.gbi_MCMC(x,samples = 10, s = 1:10)
devtools::load_all(".")
matrix(rbinom(10 * 20, 1, 0.25), 10, 20)
gbi_MCMC_iters(matrix(rbinom(10 * 20, 1, 0.25), 10, 20))
gbi_MCMC_iters(matrix(rbinom(10 * 50, 1, 0.25), 10, 50))
gbi_MCMC(matrix(rbinom(10 * 50, 1, 0.25), 10, 50))
